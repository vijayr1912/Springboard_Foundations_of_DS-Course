---
title: "Building a Movie Recommendation System using R- Recommenderlab package"
author: "Vijay Raghunath, mentored by Amit Dingare"
date: "November, 2016"
output: html_notebook
---

## Project Overview

In this project, we develop a recommender system for recommending movies for the MovieLens database.

Initially the recommender system will be build using the colloborative filtering recommender (CFR) algorithm.

The basic idea of CFR systems is that, if two users share the same interests in the past, e.g. they liked the same book or the same movie, they will also have similar tastes in the future. If, for example, user A and user B have a similar purchase history and user A recently bought a book that user B has not yet seen, the basic idea is to propose this book to user B.

The collaborative filtering approach considers only user preferences and does not take into account the features or contents of the items (books or movies) being recommended.

## Used Libraries

The following libraries were used in this project:

```{r libs, warning=FALSE, error=FALSE, message=FALSE}
library(recommenderlab)
library(ggplot2)
library(tidyr)
library(data.table)
```

## UML class diagram for package recommenderlab
image: ![](recommenderlab-UML.png)

By using the algorithms available in Recommenderlab package, we can achieve 2-fold purpose:

* Predict the ratings for the movies that the user has not seen
* After having predicted all the ratings for the user, we can make a top-N recommendation for the users. This top-N recommendation list can be further drilled down for the genre preferred by the user.

### Recommenderlab Infrastructure
The package uses the abstract ratingMatrix to provide a common interface for rating data.
ratingMatrix implements many methods typically available for matrix-like objects.
For example, dim(), dimnames(), colCounts(), rowCounts(), colMeans(), rowMeans(), colSums()
and rowSums(). Additionally sample() can be used to sample from users (rows) and image()
produces an image plot.

For ratingMatrix we provide two concrete implementations realRatingMatrix and
binaryRatingMatrix to represent different types of rating matrices.
 
* realRatingMatrix - Implements a rating matrix with real valued ratings stored in sparse format defined in package Matrix. Sparse matrices in Matrix typically do not store 0s explicitly, however for realRatingMatrix we use these sparse matrices such that instead of 0s, NAs are not explicitly stored.

* binaryRatingMatrix - implements a 0-1 rating matrix using the implementation of itemMatrix
defined in package arules. itemMatrix stores only the ones and internally uses a sparse rep-
resentation from package Matrix. With this class structure recommenderlab can be easily
extended to other forms of rating matrices with different concepts for efficient storage in the
future.

### Exploring Parameters of Recommendation Models
```{r}
recommender_models <- recommenderRegistry$get_entries(dataType = "realRatingMatrix")
names(recommender_models)
lapply(recommender_models, "[[", "description")
```



## Dataset

The datasets for this project can be downloaded from the following site:
http://grouplens.org/datasets/movielens/latest.

There are two sets of data having different number of observations –

1. Small dataset - It contains 105339 ratings and 6138 tag applications across 10329 movies. These data were created by 668 users between April 03, 1996 and January 09, 2016. 

2. Large dataset- It contains 22884377 ratings and 586994 tag applications across 34208 movies. These data were created by 247753 users between January 09, 1995 and January 29, 2016.

For initial model building and validation, the smaller dataset is used.

The data are contained in four files: links.csv, movies.csv, ratings.csv and tags.csv. 

A brief description of the data files is as below - 

File Name | File Description
------------- | -------------
ratings.csv | All ratings are contained in the file `ratings.csv`. Each line of this file after                  the header row represents one rating of one movie by one user, and has the                       following format: `userId, movieId, rating, timestamp`.
movies.csv | Movie information is contained in the file `movies.csv`. Each line of this file                 after the header row represents one movie, and has the following format:                         `movieId, title, genres`. Movie titles are entered manually or imported from                     <https://www.themoviedb.org/>, and include the year of release in parentheses.Errors             and inconsistencies may exist in these titles.
links.csv | Identifiers that can be used to link to other sources of movie data are contained in             the file `links.csv`. Each line of this file after the header row represents one                 movie, and has the following format: `movieId, imdbId, tmdbId`.
tags.csv | All tags are contained in the file `tags.csv`. Each line of this file after the header             row represents one tag applied to one movie by one user, and has the following                   format: `userId, movieId, tag, timestamp`.

We only use the files movies.csv and ratings.csv to build a recommendation system. These files are used to build the user item ratings matrix, needed by the colloborative algorithms that are available with the *Recommenderlab* package.

```{r data_load, warning=FALSE, error=FALSE, echo=FALSE}
movies <- read.csv("data/movies.csv",stringsAsFactors=FALSE)
ratings <- read.csv("data/ratings.csv")
```

A summary of *movies* is given below, together with several first rows of a dataframe:
```{r mov_summ, warning=FALSE, error=FALSE, message=FALSE}
summary(movies)
head(movies)
```

And here is a summary and a head of *ratings*:
```{r rat_summ, warning=FALSE, error=FALSE, message=FALSE}
summary(ratings)
head(ratings)
```

## Data Pre-processing

### Extract a list of genres
Using __one-hot encoding__ to create a matrix of corresponding genres for each movie. This will help us to generate the list of recommendations for movies based on genres preferred by the user.
Even if we do not use the matrix to give genre based recommendation, we will be needing it to find similarities between users for the rating matrix.
```{r}
genres <- as.data.frame(movies$genres, stringsAsFactors=FALSE)

genres2 <- as.data.frame(tstrsplit(genres[,1], '[|]', 
                                   type.convert=TRUE), 
                         stringsAsFactors=FALSE)
colnames(genres2) <- c(1:10)

genre_list <- c("Action", "Adventure", "Animation", "Children", 
                "Comedy", "Crime","Documentary", "Drama", "Fantasy",
                "Film-Noir", "Horror", "Musical", "Mystery","Romance",
                "Sci-Fi", "Thriller", "War", "Western") # we have 18 genres in total

genre_matrix <- matrix(0,10330,18) #empty matrix, 10330=no of movies+1, 18=no of genres
genre_matrix[1,] <- genre_list #set first row to genre list
colnames(genre_matrix) <- genre_list #set column names to genre list

#iterate through matrix
for (i in 1:nrow(genres2)) {
  for (c in 1:ncol(genres2)) {
    genmat_col = which(genre_matrix[1,] == genres2[i,c])
    genre_matrix[i+1,genmat_col] <- 1
  }
}

 #remove first row, which was the genre list
genre_matrix2 <- as.data.frame(genre_matrix[-1,], stringsAsFactors=FALSE)
for (c in 1:ncol(genre_matrix2)) {
  genre_matrix2[,c] <- as.integer(genre_matrix2[,c])  #convert from characters to integers
} 

```
```{r rat_genre_matric, warning=FALSE, error=FALSE, message=FALSE}
summary(genre_matrix2)
head(genre_matrix2)
```


```{r search_genres, warning=FALSE, error=FALSE, echo=FALSE}
search_matrix <- cbind(movies[,1:2], genre_matrix2)
head(search_matrix)
```
It is seen from the ratings matrix above that each movie can correspond to one or more genres.

### Converting ratings matrix in a proper format

In order to use the ratings data for building a recommendation engine with *recommenderlab*, convert rating matrix into a sparse matrix of type *realRatingMatrix*.

```{r rat_mat, warning=FALSE, error=FALSE, echo=FALSE}
ratingmat <- dcast(ratings, userId~movieId, value.var = "rating", na.rm=FALSE)
ratingmat <- as.matrix(ratingmat[,-1]) #remove userIds

#Convert rating matrix into a recommenderlab sparse matrix
ratingmat <- as(ratingmat, "realRatingMatrix")
```
668 x 10325 rating matrix of class 'realRatingMatrix' with 105339 ratings.
<!-- ### Synchronize dimensions of matrices (???) -->

<!-- ```{r mat_dims, warning=FALSE, error=FALSE} -->
<!-- #Remove rows that are not rated from movies dataset -->
<!-- movieIds <- length(unique(movies$movieId)) #10329 -->
<!-- ratingmovieIds <- length(unique(ratings$movieId)) #10325 -->
<!-- movies2 <- movies[-which((movies$movieId %in% ratings$movieId) == FALSE),] -->
<!-- rownames(movies2) <- NULL -->

<!-- #Remove rows that are not rated from genre_matrix2 -->
<!-- genre_matrix3 <- genre_matrix2[-which((movies$movieId %in% ratings$movieId) == FALSE),] -->
<!-- rownames(genre_matrix3) <- NULL -->
<!-- ``` -->

## Explore values of movies ratings
```{r rate_values, warning=FALSE, error=FALSE}
vector_ratings <- as.vector(ratingmat@data)
unique(vector_ratings) # what are unique values of ratings

table_ratings <- table(vector_ratings) # what is the count of each rating value
table_ratings
```
There are 11 unique score values. The lower values mean lower ratings and vice versa.

### Distribution of the ratings

According to the documentation, a rating equal to 0 represents a missing value, hence it is removed from the dataset before visualizing the results.
```{r}
 # rating == 0 are NA values
vector_ratings <- vector_ratings[vector_ratings != 0]
vector_ratings <- factor(vector_ratings)

qplot(vector_ratings) + ggtitle("Distribution of the ratings")
```
There are less low (less than 3) rating scores, the majority of movies are rated with a score of 3 or higher. The most common rating is 4.

### Number of views of the top movies
```{r  top_no, warning=FALSE, error=FALSE, echo=FALSE}
views_per_movie <- colCounts(ratingmat) # count views for each movie

table_views <- data.frame(movie = names(views_per_movie),
                          views = views_per_movie) # create dataframe of views
table_views <- table_views[order(table_views$views, 
                                 decreasing = TRUE), ] # sort by number of views
table_views$title <- NA
for (i in 1:10325){
  table_views[i,3] <- as.character(subset(movies, 
                                         movies$movieId == table_views[i,1])$title)
}

table_views[1:6,]

ggplot(table_views[1:6, ], aes(x = title, y = views)) +
  geom_bar(stat="identity") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
ggtitle("Number of views of the top movies")

```
From the plot, it can be seen that "Pulp Fiction (1994)" is the most viewed movie, exceeding the second-most-viewed "Forrest Gump (1994)" by 14 views.

### Distribution of the average movie rating
```{r avg_rat, warning=FALSE, error=FALSE, echo=FALSE, message=FALSE}
average_ratings <- colMeans(ratingmat)

qplot(average_ratings) + 
  stat_bin(binwidth = 0.1) +
  ggtitle("Distribution of the average movie rating")
```
The distribution above shows the distribution of the average movie rating. The highest value is around 3, and there are a few movies whose rating is either 1 or 5. Probably, the reason is that these movies received a rating from a few people only, so shouldn't take them into account.

Assigning a threshold value of minimum of 50 views per user, create a subset of only relevant movies. 
```{r}
average_ratings_relevant <- average_ratings[views_per_movie > 50] 
qplot(average_ratings_relevant) + 
  stat_bin(binwidth = 0.1) +
  ggtitle(paste("Distribution of the relevant average ratings"))
```

The second image above shows the distribution of the relevant average ratings. All the rankings are between 2.16 and 4.45. As expected, the extremes were removed. The highest value changes, and now it is around 4.


### Heatmap of the rating matrix
Visualizing the whole matrix of ratings by building a heat map whose colors represent the ratings. Each row of the matrix corresponds to a user, each column to a movie, and each cell to its rating.
```{r heat_rate, warning=FALSE, error=FALSE, echo=FALSE}
image(ratingmat, main = "Heatmap of the rating matrix")

```

Since there are too many users and items, the heatmap chart is hard to read hard as it has too many dimensions.

```{r}
image(ratingmat[1:20, 1:25], main = "Heatmap of the first 20 rows and 25 columns")
```
Zooming in on the first rows and columns, it can be observed that the some users saw more movies than the others.

To avoid this user bias, an efficient recommendation algorithm should select the most relevant users (the users who have seen many movies) and movies (the movies that have been seen by many users). To select the most relevant users and movies, the following steps are followed -

1. Determine the minimum number of movies per user.
2. Determine the minimum number of users per movie.
3. Select the users and movies matching these criteria.

```{r heat_relev, warning=FALSE, error=FALSE, echo=FALSE}
min_n_movies <- quantile(rowCounts(ratingmat), 0.99)
min_n_users <- quantile(colCounts(ratingmat), 0.99)
print("Minimum number of movies per user:")
min_n_movies
print("Minimum number of users per movie:")
min_n_users

image(ratingmat[rowCounts(ratingmat) > min_n_movies,
                 colCounts(ratingmat) > min_n_users], 
main = "Heatmap of the top users and movies")
```
From above heatmap the following points can be observed - 

* Of the users having watched more movies, most of them have seen all the top movies.
* Some columns of the heatmap are darker than the others, meaning that these columns represent the highest-rated movies.
* Conversely, darker rows represent users giving higher ratings.

Because of the above factors, it would be a good to normalize the data before building the model.

## Data Preparation

The data preparation process consists of the following steps:

1. Select the relevant data.
2. Normalize the data.
3. Binarize the data.

In order to select the most relevant data, the minimum number of users per rated movie is defined as 50 and the minimum views number per movie as 50:

```{r rel_data, warning=FALSE, error=FALSE, echo=FALSE}
ratings_movies <- ratingmat[rowCounts(ratingmat) > 50,
                             colCounts(ratingmat) > 50]
```
420 x 447 rating matrix of class ‘realRatingMatrix’ with 38341 ratings.
```{r}

Such a selection of the most relevant data contains 420 users and 447 movies, compared to previous 668 users and 10325 movies in the total dataset.


